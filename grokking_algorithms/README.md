# 《算法图解》笔记

## ch1
 
- 本书使用大**O**法讨论运行时间时，*log*指的都是*log2* （以2为底）。
- 二分查找：仅当列表有序时，二分查找才管用。
- 大**O**表示法表示的是最糟的情形。

## ch2

- 查找频繁->数组；插入、删除频繁->链表。
- 选择排序的工作原理：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序
元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

## ch3

- 编写递归函数时，必须告诉它何时停止。正因如此，每个递归函数都有两部分：*基线条件(base case)和递归条件(recursive case)*。递归条件指的是函数调用自己，
基线条件指的是函数不再调用自己，从而避免无限循环。

## ch4

- *分而治之（divide and conquer, D&C)*的工作原理：
  - 找出简单的基线条件；
  - 确定如何缩小问题的规模，使其符合基线条件。
- D&C并非可用于解决问题的算法，而是一种解决问题的思路。

> 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。

## ch5

- 散列表也被称为哈希表、散列映射、映射、字典和关联数组。
- 散列表的应用：
  - 用于查找
  - 防止重复
  - 用作缓存
- 哈希冲突(collision)，也叫哈希碰撞。
- 解决哈希冲突的常用方法：链地址法，开放地址法。
- 装填因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：**一旦装填因子大于0.7，就调整散列表的长度**。
 
## ch6

- 在我所知道的算法中，图算法应该是最有用的。
- 队列是一种*先进先出* （First In First Out, FIFO）的数据结构，而栈是一种*后进先出*（Last In First Out, LIFO）的数据结构。
- 有向图：*directed graph*，无向图：*undirected graph*。

## ch7

- 带权重的图称为*加权图*（weighted graph），不带权重的图称为*非加权图*（unweighted graph）。
- 要计算非加权图中的最短路径，可使用*广度优先搜索*，要计算加权图中的最短路径，可使用*Dijkstra算法*。
- 无向图意味着两个节点彼此指向对方，其实就是环。Dijkstra算法只适用于*有向无环图（directed acyclic graph，DAG）*。

## ch8

- 贪婪算法：*每一步都选择局部最优解*。

## ch9

- 动态规划：*仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用*。
- 费曼算法（*Feynman algorithm*）
  - 将问题写下来。
  - 好好思考。
  - 将答案写下来。
  
## ch11

- 布隆过滤器：
  - 使用散列表时，答案绝对可靠；而使用布隆过滤器时，答案却很可能是正确的。
  - 不可能出现漏报的情况。
  
